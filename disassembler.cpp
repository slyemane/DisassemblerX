// DisassemblerX - Professional x86-64 Disassembler
// Copyright (C) 2025 @slyemane - https://github.com/slyemane
// All Rights Reserved
// 
// DisassemblerX is a production-grade x86-64 disassembler
// Developed and maintained by @slyemane
// GitHub: https://github.com/slyemane
//
// Version: 1.0.0
// License: Proprietary - Coded by @slyemane

#define _CRT_SECURE_NO_WARNINGS  // For Windows compatibility

#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <iomanip>
#include <sstream>
#include <memory>
#include <algorithm>
#include <cstring>
#include <string>
#include <sys/stat.h>
#include <ctime>
#include <chrono>

#ifdef _WIN32
#include <windows.h>
#include <io.h>
#undef min
#undef max
#else
#include <elf.h>
#include <unistd.h>
#endif

// ==================== DisassemblerX Configuration ====================
#define DISASSEMBLERX_VERSION "1.0.0"
#define DISASSEMBLERX_AUTHOR "@slyemane"
#define DISASSEMBLERX_GITHUB "https://github.com/slyemane"
#define DISASSEMBLERX_COPYRIGHT "Copyright (C) 2025 @slyemane - All Rights Reserved"

// ==================== Type Definitions ====================
using byte = uint8_t;
using word = uint16_t;
using dword = uint32_t;
using qword = uint64_t;

// ==================== File Utility Functions ====================
bool fileExists(const std::string& path) {
#ifdef _WIN32
    return _access(path.c_str(), 0) == 0;
#else
    return access(path.c_str(), F_OK) == 0;
#endif
}

size_t getFileSize(const std::string& path) {
    struct stat st;
    if (stat(path.c_str(), &st) == 0) {
        return st.st_size;
    }
    return 0;
}

std::string getCurrentDateTime() {
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);

    char buffer[80];
#ifdef _WIN32
    struct tm timeinfo;
    localtime_s(&timeinfo, &time);
    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", &timeinfo);
#else
    struct tm* timeinfo = localtime(&time);
    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", timeinfo);
#endif

    return std::string(buffer);
}

// ==================== Instruction Components ====================
enum class RegisterType {
    RAX = 0, RCX, RDX, RBX, RSP, RBP, RSI, RDI,
    R8, R9, R10, R11, R12, R13, R14, R15,
    EAX = 0, ECX, EDX, EBX, ESP, EBP, ESI, EDI,
    AX = 0, CX, DX, BX, SP, BP, SI, DI,
    AL = 0, CL, DL, BL, AH, CH, DH, BH
};

enum class OperandSize {
    BYTE = 1,
    WORD = 2,
    DWORD = 4,
    QWORD = 8
};

enum class AddressMode {
    REGISTER,
    MEMORY,
    IMMEDIATE,
    REGISTER_INDIRECT,
    DISPLACEMENT,
    SIB
};

// ==================== Instruction Structure ====================
struct Operand {
    AddressMode mode;
    RegisterType reg;
    RegisterType base;
    RegisterType index;
    byte scale;
    int64_t displacement;
    int64_t immediate;
    OperandSize size;
    bool isValid;

    Operand() : mode(AddressMode::REGISTER), reg(RegisterType::RAX),
        base(RegisterType::RAX), index(RegisterType::RAX),
        scale(1), displacement(0), immediate(0),
        size(OperandSize::QWORD), isValid(false) {
    }
};

struct Instruction {
    std::string mnemonic;
    std::vector<Operand> operands;
    qword address;
    std::vector<byte> bytes;
    size_t length;
    bool isValid;

    Instruction() : address(0), length(0), isValid(false) {}
};

// ==================== Output Manager ====================
class OutputManager {
private:
    std::unique_ptr<std::ofstream> outputFile;
    bool fileOutputEnabled;
    std::string outputFileName;

    void writeHeader() {
        if (!outputFile) return;
        *outputFile << "================================================================================\n";
        *outputFile << "                              DisassemblerX Output File                        \n";
        *outputFile << "                        Powered by @slyemane Technology                        \n";
        *outputFile << "================================================================================\n";
        *outputFile << " DisassemblerX Version: " << DISASSEMBLERX_VERSION << "\n";
        *outputFile << " Author: " << DISASSEMBLERX_AUTHOR << "\n";
        *outputFile << " GitHub: " << DISASSEMBLERX_GITHUB << "\n";
        *outputFile << " Generated: " << getCurrentDateTime() << "\n";
        *outputFile << " " << DISASSEMBLERX_COPYRIGHT << "\n";
        *outputFile << "================================================================================\n\n";
    }

    void writeFooter() {
        if (!outputFile) return;
        *outputFile << "\n================================================================================\n";
        *outputFile << " End of DisassemblerX Output\n";
        *outputFile << " Generated by DisassemblerX v" << DISASSEMBLERX_VERSION << "\n";
        *outputFile << " Coded by @slyemane - " << DISASSEMBLERX_GITHUB << "\n";
        *outputFile << " Timestamp: " << getCurrentDateTime() << "\n";
        *outputFile << "================================================================================\n";
    }

public:
    OutputManager() : fileOutputEnabled(false) {}

    // Destructor must be public
    ~OutputManager() {
        disableFileOutput();
    }

    bool enableFileOutput(const std::string& filename) {
        outputFileName = filename;
        outputFile = std::make_unique<std::ofstream>(filename);
        if (outputFile->is_open()) {
            fileOutputEnabled = true;
            writeHeader();
            return true;
        }
        return false;
    }

    void disableFileOutput() {
        if (fileOutputEnabled && outputFile && outputFile->is_open()) {
            writeFooter();
            outputFile->close();
        }
        fileOutputEnabled = false;
    }

    void write(const std::string& text) {
        std::cout << text;
        if (fileOutputEnabled && outputFile && outputFile->is_open()) {
            *outputFile << text;
            outputFile->flush();
        }
    }

    void writeLine(const std::string& text = "") {
        write(text + "\n");
    }
};

// ==================== X86-64 Decoder ====================
class X86Decoder {
private:
    const byte* data;
    size_t dataSize;
    size_t currentOffset;
    qword baseAddress;

    struct Prefixes {
        bool lock = false;
        bool repne = false;
        bool rep = false;
        bool operandSizeOverride = false;
        bool addressSizeOverride = false;
        bool rex = false;
        byte rexW = 0;
        byte rexR = 0;
        byte rexX = 0;
        byte rexB = 0;
        byte segmentOverride = 0;

        void reset() {
            *this = Prefixes();
        }
    } prefixes;

    const std::map<std::pair<RegisterType, OperandSize>, std::string> registerNames = {
        // 64-bit registers
        {{RegisterType::RAX, OperandSize::QWORD}, "rax"},
        {{RegisterType::RCX, OperandSize::QWORD}, "rcx"},
        {{RegisterType::RDX, OperandSize::QWORD}, "rdx"},
        {{RegisterType::RBX, OperandSize::QWORD}, "rbx"},
        {{RegisterType::RSP, OperandSize::QWORD}, "rsp"},
        {{RegisterType::RBP, OperandSize::QWORD}, "rbp"},
        {{RegisterType::RSI, OperandSize::QWORD}, "rsi"},
        {{RegisterType::RDI, OperandSize::QWORD}, "rdi"},
        {{RegisterType::R8, OperandSize::QWORD}, "r8"},
        {{RegisterType::R9, OperandSize::QWORD}, "r9"},
        {{RegisterType::R10, OperandSize::QWORD}, "r10"},
        {{RegisterType::R11, OperandSize::QWORD}, "r11"},
        {{RegisterType::R12, OperandSize::QWORD}, "r12"},
        {{RegisterType::R13, OperandSize::QWORD}, "r13"},
        {{RegisterType::R14, OperandSize::QWORD}, "r14"},
        {{RegisterType::R15, OperandSize::QWORD}, "r15"},
        // 32-bit registers
        {{RegisterType::EAX, OperandSize::DWORD}, "eax"},
        {{RegisterType::ECX, OperandSize::DWORD}, "ecx"},
        {{RegisterType::EDX, OperandSize::DWORD}, "edx"},
        {{RegisterType::EBX, OperandSize::DWORD}, "ebx"},
        {{RegisterType::ESP, OperandSize::DWORD}, "esp"},
        {{RegisterType::EBP, OperandSize::DWORD}, "ebp"},
        {{RegisterType::ESI, OperandSize::DWORD}, "esi"},
        {{RegisterType::EDI, OperandSize::DWORD}, "edi"},
        {{RegisterType::R8, OperandSize::DWORD}, "r8d"},
        {{RegisterType::R9, OperandSize::DWORD}, "r9d"},
        {{RegisterType::R10, OperandSize::DWORD}, "r10d"},
        {{RegisterType::R11, OperandSize::DWORD}, "r11d"},
        {{RegisterType::R12, OperandSize::DWORD}, "r12d"},
        {{RegisterType::R13, OperandSize::DWORD}, "r13d"},
        {{RegisterType::R14, OperandSize::DWORD}, "r14d"},
        {{RegisterType::R15, OperandSize::DWORD}, "r15d"},
        // 16-bit registers
        {{RegisterType::AX, OperandSize::WORD}, "ax"},
        {{RegisterType::CX, OperandSize::WORD}, "cx"},
        {{RegisterType::DX, OperandSize::WORD}, "dx"},
        {{RegisterType::BX, OperandSize::WORD}, "bx"},
        {{RegisterType::SP, OperandSize::WORD}, "sp"},
        {{RegisterType::BP, OperandSize::WORD}, "bp"},
        {{RegisterType::SI, OperandSize::WORD}, "si"},
        {{RegisterType::DI, OperandSize::WORD}, "di"},
        {{RegisterType::R8, OperandSize::WORD}, "r8w"},
        {{RegisterType::R9, OperandSize::WORD}, "r9w"},
        {{RegisterType::R10, OperandSize::WORD}, "r10w"},
        {{RegisterType::R11, OperandSize::WORD}, "r11w"},
        {{RegisterType::R12, OperandSize::WORD}, "r12w"},
        {{RegisterType::R13, OperandSize::WORD}, "r13w"},
        {{RegisterType::R14, OperandSize::WORD}, "r14w"},
        {{RegisterType::R15, OperandSize::WORD}, "r15w"},
        // 8-bit registers
        {{RegisterType::AL, OperandSize::BYTE}, "al"},
        {{RegisterType::CL, OperandSize::BYTE}, "cl"},
        {{RegisterType::DL, OperandSize::BYTE}, "dl"},
        {{RegisterType::BL, OperandSize::BYTE}, "bl"},
        {{RegisterType::AH, OperandSize::BYTE}, "ah"},
        {{RegisterType::CH, OperandSize::BYTE}, "ch"},
        {{RegisterType::DH, OperandSize::BYTE}, "dh"},
        {{RegisterType::BH, OperandSize::BYTE}, "bh"},
        {{RegisterType::R8, OperandSize::BYTE}, "r8b"},
        {{RegisterType::R9, OperandSize::BYTE}, "r9b"},
        {{RegisterType::R10, OperandSize::BYTE}, "r10b"},
        {{RegisterType::R11, OperandSize::BYTE}, "r11b"},
        {{RegisterType::R12, OperandSize::BYTE}, "r12b"},
        {{RegisterType::R13, OperandSize::BYTE}, "r13b"},
        {{RegisterType::R14, OperandSize::BYTE}, "r14b"},
        {{RegisterType::R15, OperandSize::BYTE}, "r15b"}
    };

    byte readByte() {
        if (currentOffset >= dataSize) return 0;
        return data[currentOffset++];
    }

    word readWord() {
        word value = 0;
        if (currentOffset + 1 < dataSize) {
            value = *reinterpret_cast<const word*>(&data[currentOffset]);
            currentOffset += 2;
        }
        return value;
    }

    dword readDword() {
        dword value = 0;
        if (currentOffset + 3 < dataSize) {
            value = *reinterpret_cast<const dword*>(&data[currentOffset]);
            currentOffset += 4;
        }
        return value;
    }

    qword readQword() {
        qword value = 0;
        if (currentOffset + 7 < dataSize) {
            value = *reinterpret_cast<const qword*>(&data[currentOffset]);
            currentOffset += 8;
        }
        return value;
    }

    void decodePrefixes() {
        prefixes.reset();
        bool foundPrefix = true;

        while (foundPrefix && currentOffset < dataSize) {
            byte prefix = data[currentOffset];
            foundPrefix = true;

            switch (prefix) {
            case 0xF0: prefixes.lock = true; currentOffset++; break;
            case 0xF2: prefixes.repne = true; currentOffset++; break;
            case 0xF3: prefixes.rep = true; currentOffset++; break;
            case 0x66: prefixes.operandSizeOverride = true; currentOffset++; break;
            case 0x67: prefixes.addressSizeOverride = true; currentOffset++; break;
            case 0x26: case 0x2E: case 0x36: case 0x3E:
            case 0x64: case 0x65:
                prefixes.segmentOverride = prefix;
                currentOffset++;
                break;
            default:
                if ((prefix & 0xF0) == 0x40) {
                    prefixes.rex = true;
                    prefixes.rexW = (prefix >> 3) & 1;
                    prefixes.rexR = (prefix >> 2) & 1;
                    prefixes.rexX = (prefix >> 1) & 1;
                    prefixes.rexB = prefix & 1;
                    currentOffset++;
                }
                else {
                    foundPrefix = false;
                }
                break;
            }
        }
    }

    void decodeModRM(byte& mod, byte& reg, byte& rm, const byte modrm) {
        mod = (modrm >> 6) & 0x03;
        reg = (modrm >> 3) & 0x07;
        rm = modrm & 0x07;
    }

    Operand decodeOperand(byte mod, byte rm, OperandSize size) {
        Operand op;
        op.size = size;
        op.isValid = true;

        if (mod == 3) {
            op.mode = AddressMode::REGISTER;
            op.reg = static_cast<RegisterType>(rm + (prefixes.rexB ? 8 : 0));
        }
        else {
            op.mode = AddressMode::MEMORY;

            if (rm == 4) {
                byte sib = readByte();
                byte scale = (sib >> 6) & 0x03;
                byte index = (sib >> 3) & 0x07;
                byte base = sib & 0x07;

                op.scale = 1 << scale;
                if (index != 4) {
                    op.index = static_cast<RegisterType>(index + (prefixes.rexX ? 8 : 0));
                }
                op.base = static_cast<RegisterType>(base + (prefixes.rexB ? 8 : 0));
            }
            else if (mod == 0 && rm == 5) {
                op.displacement = static_cast<int32_t>(readDword());
                op.mode = AddressMode::DISPLACEMENT;
            }
            else {
                op.base = static_cast<RegisterType>(rm + (prefixes.rexB ? 8 : 0));
            }

            if (mod == 1) {
                op.displacement = static_cast<int8_t>(readByte());
            }
            else if (mod == 2) {
                op.displacement = static_cast<int32_t>(readDword());
            }
        }

        return op;
    }

    std::string getRegisterName(RegisterType reg, OperandSize size) {
        auto it = registerNames.find({ reg, size });
        if (it != registerNames.end()) {
            return it->second;
        }
        return "unknown";
    }

public:
    X86Decoder(const byte* data, size_t size, qword base)
        : data(data), dataSize(size), currentOffset(0), baseAddress(base) {
    }

    std::string formatOperand(const Operand& op) {
        std::stringstream ss;

        switch (op.mode) {
        case AddressMode::REGISTER:
            ss << getRegisterName(op.reg, op.size);
            break;
        case AddressMode::MEMORY:
            ss << "QWORD PTR [";
            ss << getRegisterName(op.base, OperandSize::QWORD);
            if (op.displacement != 0) {
                if (op.displacement > 0) {
                    ss << "+" << std::hex << "0x" << op.displacement;
                }
                else {
                    ss << "-" << std::hex << "0x" << -op.displacement;
                }
            }
            ss << "]";
            break;
        case AddressMode::IMMEDIATE:
            ss << "0x" << std::hex << op.immediate;
            break;
        case AddressMode::DISPLACEMENT:
            ss << "[0x" << std::hex << (baseAddress + currentOffset + op.displacement) << "]";
            break;
        default:
            ss << "unknown";
        }

        return ss.str();
    }

    Instruction decodeInstruction() {
        Instruction inst;
        inst.address = baseAddress + currentOffset;
        size_t startOffset = currentOffset;

        if (currentOffset >= dataSize) {
            inst.isValid = false;
            return inst;
        }

        decodePrefixes();

        byte opcode = readByte();
        byte secondOpcode = 0;

        if (opcode == 0x0F) {
            secondOpcode = readByte();
            decodeExtendedOpcode(inst, secondOpcode);
        }
        else {
            decodePrimaryOpcode(inst, opcode);
        }

        inst.length = currentOffset - startOffset;
        inst.bytes.assign(data + startOffset, data + currentOffset);
        inst.isValid = true;

        return inst;
    }

    void decodePrimaryOpcode(Instruction& inst, byte opcode) {
        OperandSize opSize = prefixes.rexW ? OperandSize::QWORD :
            prefixes.operandSizeOverride ? OperandSize::WORD :
            OperandSize::DWORD;

        switch (opcode) {
        case 0x00: case 0x01: case 0x02: case 0x03: {
            inst.mnemonic = "add";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            if (opcode & 1) {
                inst.operands.push_back(decodeOperand(mod, rm, opSize));
                Operand regOp;
                regOp.mode = AddressMode::REGISTER;
                regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
                regOp.size = opSize;
                regOp.isValid = true;
                inst.operands.push_back(regOp);
            }
            else {
                inst.operands.push_back(decodeOperand(mod, rm, OperandSize::BYTE));
                Operand regOp;
                regOp.mode = AddressMode::REGISTER;
                regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
                regOp.size = OperandSize::BYTE;
                regOp.isValid = true;
                inst.operands.push_back(regOp);
            }
            break;
        }

        case 0x28: case 0x29: case 0x2A: case 0x2B: {
            inst.mnemonic = "sub";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            inst.operands.push_back(decodeOperand(mod, rm, opSize));
            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
            regOp.size = opSize;
            regOp.isValid = true;
            inst.operands.push_back(regOp);
            break;
        }

        case 0x30: case 0x31: case 0x32: case 0x33: {
            inst.mnemonic = "xor";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            inst.operands.push_back(decodeOperand(mod, rm, opSize));
            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
            regOp.size = opSize;
            regOp.isValid = true;
            inst.operands.push_back(regOp);
            break;
        }

        case 0x50: case 0x51: case 0x52: case 0x53:
        case 0x54: case 0x55: case 0x56: case 0x57: {
            inst.mnemonic = "push";
            Operand op;
            op.mode = AddressMode::REGISTER;
            op.reg = static_cast<RegisterType>((opcode & 0x07) + (prefixes.rexB ? 8 : 0));
            op.size = opSize;
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0x58: case 0x59: case 0x5A: case 0x5B:
        case 0x5C: case 0x5D: case 0x5E: case 0x5F: {
            inst.mnemonic = "pop";
            Operand op;
            op.mode = AddressMode::REGISTER;
            op.reg = static_cast<RegisterType>((opcode & 0x07) + (prefixes.rexB ? 8 : 0));
            op.size = opSize;
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0x88: case 0x89: case 0x8A: case 0x8B: {
            inst.mnemonic = "mov";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            OperandSize size = (opcode & 1) ? opSize : OperandSize::BYTE;

            if (opcode & 2) {
                Operand regOp;
                regOp.mode = AddressMode::REGISTER;
                regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
                regOp.size = size;
                regOp.isValid = true;
                inst.operands.push_back(regOp);
                inst.operands.push_back(decodeOperand(mod, rm, size));
            }
            else {
                inst.operands.push_back(decodeOperand(mod, rm, size));
                Operand regOp;
                regOp.mode = AddressMode::REGISTER;
                regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
                regOp.size = size;
                regOp.isValid = true;
                inst.operands.push_back(regOp);
            }
            break;
        }

        case 0xB0: case 0xB1: case 0xB2: case 0xB3:
        case 0xB4: case 0xB5: case 0xB6: case 0xB7: {
            inst.mnemonic = "mov";
            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>((opcode & 0x07) + (prefixes.rexB ? 8 : 0));
            regOp.size = OperandSize::BYTE;
            regOp.isValid = true;
            inst.operands.push_back(regOp);

            Operand immOp;
            immOp.mode = AddressMode::IMMEDIATE;
            immOp.immediate = readByte();
            immOp.isValid = true;
            inst.operands.push_back(immOp);
            break;
        }

        case 0xB8: case 0xB9: case 0xBA: case 0xBB:
        case 0xBC: case 0xBD: case 0xBE: case 0xBF: {
            inst.mnemonic = "mov";
            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>((opcode & 0x07) + (prefixes.rexB ? 8 : 0));
            regOp.size = opSize;
            regOp.isValid = true;
            inst.operands.push_back(regOp);

            Operand immOp;
            immOp.mode = AddressMode::IMMEDIATE;
            if (prefixes.rexW) {
                immOp.immediate = readQword();
            }
            else if (prefixes.operandSizeOverride) {
                immOp.immediate = readWord();
            }
            else {
                immOp.immediate = readDword();
            }
            immOp.isValid = true;
            inst.operands.push_back(immOp);
            break;
        }

        case 0xE8: {
            inst.mnemonic = "call";
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = baseAddress + currentOffset + 4 + static_cast<int32_t>(readDword());
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0xE9: {
            inst.mnemonic = "jmp";
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = baseAddress + currentOffset + 4 + static_cast<int32_t>(readDword());
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0xEB: {
            inst.mnemonic = "jmp";
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = baseAddress + currentOffset + 1 + static_cast<int8_t>(readByte());
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0xC3: {
            inst.mnemonic = "ret";
            break;
        }

        case 0xC2: {
            inst.mnemonic = "ret";
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = readWord();
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0x90: {
            inst.mnemonic = "nop";
            break;
        }

        case 0xCD: {
            inst.mnemonic = "int";
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = readByte();
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0x38: case 0x39: case 0x3A: case 0x3B: {
            inst.mnemonic = "cmp";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            inst.operands.push_back(decodeOperand(mod, rm, opSize));
            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
            regOp.size = opSize;
            regOp.isValid = true;
            inst.operands.push_back(regOp);
            break;
        }

        case 0x84: case 0x85: {
            inst.mnemonic = "test";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            OperandSize size = (opcode & 1) ? opSize : OperandSize::BYTE;
            inst.operands.push_back(decodeOperand(mod, rm, size));
            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
            regOp.size = size;
            regOp.isValid = true;
            inst.operands.push_back(regOp);
            break;
        }

        case 0x8D: {
            inst.mnemonic = "lea";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
            regOp.size = opSize;
            regOp.isValid = true;
            inst.operands.push_back(regOp);
            inst.operands.push_back(decodeOperand(mod, rm, opSize));
            break;
        }

        default: {
            inst.mnemonic = "db";
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = opcode;
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }
        }
    }

    void decodeExtendedOpcode(Instruction& inst, byte opcode) {
        OperandSize opSize = prefixes.rexW ? OperandSize::QWORD :
            prefixes.operandSizeOverride ? OperandSize::WORD :
            OperandSize::DWORD;

        switch (opcode) {
        case 0x80: case 0x81: case 0x82: case 0x83:
        case 0x84: case 0x85: case 0x86: case 0x87:
        case 0x88: case 0x89: case 0x8A: case 0x8B:
        case 0x8C: case 0x8D: case 0x8E: case 0x8F: {
            const char* jccMnemonics[] = {
                "jo", "jno", "jb", "jnb", "jz", "jnz", "jbe", "jnbe",
                "js", "jns", "jp", "jnp", "jl", "jnl", "jle", "jnle"
            };
            inst.mnemonic = jccMnemonics[opcode & 0x0F];
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = baseAddress + currentOffset + 4 + static_cast<int32_t>(readDword());
            op.isValid = true;
            inst.operands.push_back(op);
            break;
        }

        case 0xB6: case 0xB7: {
            inst.mnemonic = "movzx";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
            regOp.size = opSize;
            regOp.isValid = true;
            inst.operands.push_back(regOp);

            OperandSize srcSize = (opcode == 0xB6) ? OperandSize::BYTE : OperandSize::WORD;
            inst.operands.push_back(decodeOperand(mod, rm, srcSize));
            break;
        }

        case 0xBE: case 0xBF: {
            inst.mnemonic = "movsx";
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);

            Operand regOp;
            regOp.mode = AddressMode::REGISTER;
            regOp.reg = static_cast<RegisterType>(reg + (prefixes.rexR ? 8 : 0));
            regOp.size = opSize;
            regOp.isValid = true;
            inst.operands.push_back(regOp);

            OperandSize srcSize = (opcode == 0xBE) ? OperandSize::BYTE : OperandSize::WORD;
            inst.operands.push_back(decodeOperand(mod, rm, srcSize));
            break;
        }

        case 0x90: case 0x91: case 0x92: case 0x93:
        case 0x94: case 0x95: case 0x96: case 0x97:
        case 0x98: case 0x99: case 0x9A: case 0x9B:
        case 0x9C: case 0x9D: case 0x9E: case 0x9F: {
            const char* setccMnemonics[] = {
                "seto", "setno", "setb", "setnb", "setz", "setnz", "setbe", "setnbe",
                "sets", "setns", "setp", "setnp", "setl", "setnl", "setle", "setnle"
            };
            inst.mnemonic = setccMnemonics[opcode & 0x0F];
            byte modrm = readByte();
            byte mod, reg, rm;
            decodeModRM(mod, reg, rm, modrm);
            inst.operands.push_back(decodeOperand(mod, rm, OperandSize::BYTE));
            break;
        }

        default: {
            inst.mnemonic = "db";
            Operand op;
            op.mode = AddressMode::IMMEDIATE;
            op.immediate = 0x0F;
            op.isValid = true;
            inst.operands.push_back(op);

            Operand op2;
            op2.mode = AddressMode::IMMEDIATE;
            op2.immediate = opcode;
            op2.isValid = true;
            inst.operands.push_back(op2);
            break;
        }
        }
    }

    size_t getCurrentOffset() const { return currentOffset; }
    void setCurrentOffset(size_t offset) { currentOffset = offset; }
};

// ==================== File Format Parsers ====================
class ExecutableParser {
public:
    struct Section {
        std::string name;
        qword virtualAddress;
        qword fileOffset;
        qword size;
        bool isExecutable;
    };

    virtual ~ExecutableParser() = default;
    virtual bool parse(const std::vector<byte>& data) = 0;
    virtual qword getEntryPoint() const = 0;
    virtual std::vector<Section> getSections() const = 0;
    virtual qword getImageBase() const = 0;
};

#ifdef _WIN32
class PEParser : public ExecutableParser {
private:
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS64 ntHeaders;
    std::vector<IMAGE_SECTION_HEADER> sectionHeaders;
    std::vector<Section> sections;
    bool is64Bit;

public:
    bool parse(const std::vector<byte>& data) override {
        if (data.size() < sizeof(IMAGE_DOS_HEADER)) return false;

        memcpy(&dosHeader, data.data(), sizeof(IMAGE_DOS_HEADER));
        if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) return false;

        if (data.size() < dosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS64)) return false;

        const byte* ntHeaderPtr = data.data() + dosHeader.e_lfanew;
        dword peSignature = *reinterpret_cast<const dword*>(ntHeaderPtr);
        if (peSignature != IMAGE_NT_SIGNATURE) return false;

        const IMAGE_FILE_HEADER* fileHeader = reinterpret_cast<const IMAGE_FILE_HEADER*>(ntHeaderPtr + 4);
        is64Bit = (fileHeader->Machine == IMAGE_FILE_MACHINE_AMD64);

        if (is64Bit) {
            memcpy(&ntHeaders, ntHeaderPtr, sizeof(IMAGE_NT_HEADERS64));
        }
        else {
            IMAGE_NT_HEADERS32 ntHeaders32;
            memcpy(&ntHeaders32, ntHeaderPtr, sizeof(IMAGE_NT_HEADERS32));
            ntHeaders.Signature = ntHeaders32.Signature;
            ntHeaders.FileHeader = ntHeaders32.FileHeader;
            ntHeaders.OptionalHeader.Magic = ntHeaders32.OptionalHeader.Magic;
            ntHeaders.OptionalHeader.AddressOfEntryPoint = ntHeaders32.OptionalHeader.AddressOfEntryPoint;
            ntHeaders.OptionalHeader.ImageBase = ntHeaders32.OptionalHeader.ImageBase;
            ntHeaders.OptionalHeader.SectionAlignment = ntHeaders32.OptionalHeader.SectionAlignment;
            ntHeaders.OptionalHeader.FileAlignment = ntHeaders32.OptionalHeader.FileAlignment;
        }

        const byte* sectionPtr = ntHeaderPtr + (is64Bit ? sizeof(IMAGE_NT_HEADERS64) : sizeof(IMAGE_NT_HEADERS32));
        for (int i = 0; i < ntHeaders.FileHeader.NumberOfSections; i++) {
            IMAGE_SECTION_HEADER sectionHeader;
            memcpy(&sectionHeader, sectionPtr + i * sizeof(IMAGE_SECTION_HEADER), sizeof(IMAGE_SECTION_HEADER));
            sectionHeaders.push_back(sectionHeader);

            Section sec;
            sec.name = std::string(reinterpret_cast<const char*>(sectionHeader.Name), 8);
            sec.virtualAddress = sectionHeader.VirtualAddress;
            sec.fileOffset = sectionHeader.PointerToRawData;
            sec.size = sectionHeader.SizeOfRawData;
            sec.isExecutable = (sectionHeader.Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0;
            sections.push_back(sec);
        }

        return true;
    }

    qword getEntryPoint() const override {
        return ntHeaders.OptionalHeader.AddressOfEntryPoint;
    }

    qword getImageBase() const override {
        return ntHeaders.OptionalHeader.ImageBase;
    }

    std::vector<Section> getSections() const override {
        return sections;
    }
};
#endif

// ==================== DisassemblerX Main Class ====================
class DisassemblerX {
private:
    std::unique_ptr<ExecutableParser> parser;
    std::vector<byte> fileData;
    std::string filePath;
    std::unique_ptr<OutputManager> output;

    void printHeader() {
        output->writeLine();
        output->writeLine("================================================================================");
        output->writeLine("                               DisassemblerX v" DISASSEMBLERX_VERSION);
        output->writeLine("                     Professional x86-64 Disassembler");
        output->writeLine("                        Developed by " DISASSEMBLERX_AUTHOR);
        output->writeLine("                         " DISASSEMBLERX_GITHUB);
        output->writeLine("================================================================================");
        output->writeLine();
    }

    void printSectionHeader(const std::string& sectionName, qword address, size_t size) {
        std::stringstream ss;
        ss << "\n";
        ss << "--------------------------------------------------------------------------------\n";
        ss << " Section: " << std::left << std::setw(55) << sectionName << "\n";
        ss << " Address: 0x" << std::hex << std::setw(16) << std::setfill('0') << address
            << "  Size: 0x" << std::setw(8) << size << std::setfill(' ') << "\n";
        ss << "--------------------------------------------------------------------------------\n";
        ss << "\n";
        output->write(ss.str());
    }

    std::string formatBytes(const std::vector<byte>& bytes) {
        std::stringstream ss;
        for (size_t i = 0; i < bytes.size() && i < 10; i++) {
            ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]) << " ";
        }
        std::string result = ss.str();
        if (bytes.size() > 10) {
            result += "...";
        }
        return result;
    }

    template<typename T>
    T myMin(T a, T b) {
        return (a < b) ? a : b;
    }

    std::string generateOutputFileName() {
        size_t lastDot = filePath.find_last_of('.');
        std::string baseName = (lastDot != std::string::npos) ? filePath.substr(0, lastDot) : filePath;
        return baseName + "_disassembled_by_slyemane.txt";
    }

public:
    DisassemblerX() : output(std::make_unique<OutputManager>()) {}  // Initialize output in constructor
    ~DisassemblerX() = default;  // Explicit default destructor

    bool loadFile(const std::string& path) {
        filePath = path;

        std::ifstream file(path, std::ios::binary | std::ios::ate);
        if (!file.is_open()) {
            std::cerr << "[DisassemblerX] Error: Cannot open file '" << path << "'\n";
            return false;
        }

        size_t fileSize = file.tellg();
        file.seekg(0, std::ios::beg);

        fileData.resize(fileSize);
        file.read(reinterpret_cast<char*>(fileData.data()), fileSize);
        file.close();

#ifdef _WIN32
        parser = std::make_unique<PEParser>();
#else
        parser = std::make_unique<ELFParser>();
#endif

        if (!parser->parse(fileData)) {
            std::cerr << "[DisassemblerX] Error: Failed to parse executable format\n";
            return false;
        }

        return true;
    }

    void disassemble(bool saveToFile = false) {
        if (saveToFile) {
            std::string outputFile = generateOutputFileName();
            if (output->enableFileOutput(outputFile)) {
                std::cout << "[DisassemblerX] Saving output to: " << outputFile << "\n\n";
            }
            else {
                std::cerr << "[DisassemblerX] Warning: Could not create output file\n";
            }
        }

        printHeader();

        std::stringstream info;
        info << "File: " << filePath << "\n";
        info << "Format: " <<
#ifdef _WIN32
            "PE (Portable Executable)"
#else
            "ELF (Executable and Linkable Format)"
#endif
            << "\n";
        info << "Image Base: 0x" << std::hex << parser->getImageBase() << "\n";
        info << "Entry Point: 0x" << std::hex << parser->getEntryPoint() << "\n";
        info << "Disassembled by: " << DISASSEMBLERX_AUTHOR << " - " << DISASSEMBLERX_GITHUB << "\n";
        output->write(info.str());

        auto sections = parser->getSections();

        for (const auto& section : sections) {
            if (!section.isExecutable) continue;

            printSectionHeader(section.name, parser->getImageBase() + section.virtualAddress, section.size);

            if (section.fileOffset + section.size > fileData.size()) {
                output->writeLine("Warning: Section extends beyond file bounds");
                continue;
            }

            X86Decoder decoder(
                fileData.data() + section.fileOffset,
                section.size,
                parser->getImageBase() + section.virtualAddress
            );

            size_t maxInstructions = 10000;
            size_t instructionCount = 0;

            while (decoder.getCurrentOffset() < section.size && instructionCount < maxInstructions) {
                Instruction inst = decoder.decodeInstruction();

                if (!inst.isValid) break;

                std::stringstream line;
                line << std::hex << std::setw(16) << std::setfill('0') << inst.address << "  ";
                line << std::setw(30) << std::left << std::setfill(' ') << formatBytes(inst.bytes);
                line << std::setw(8) << inst.mnemonic;

                for (size_t i = 0; i < inst.operands.size(); i++) {
                    if (i > 0) line << ", ";
                    line << decoder.formatOperand(inst.operands[i]);
                }

                output->writeLine(line.str());
                instructionCount++;
            }

            if (instructionCount >= maxInstructions) {
                output->writeLine("\n... (output truncated after " + std::to_string(maxInstructions) + " instructions)");
            }
        }

        output->writeLine("\n================================================================================");
        output->writeLine("Disassembly complete - Powered by DisassemblerX");
        output->writeLine("Created by " DISASSEMBLERX_AUTHOR " - " DISASSEMBLERX_GITHUB);
        output->writeLine("================================================================================");

        if (saveToFile) {
            output->disableFileOutput();
            std::cout << "\n[DisassemblerX] Output saved successfully!\n";
        }
    }

    void disassembleInteractive() {
        while (true) {
            std::cout << "\n================================================================================\n";
            std::cout << "                           DisassemblerX Menu                                  \n";
            std::cout << "                      Coded by @slyemane                                    \n";
            std::cout << "================================================================================\n";
            std::cout << " 1. Disassemble all executable sections                                        \n";
            std::cout << " 2. Disassemble all sections and save to file                                  \n";
            std::cout << " 3. Disassemble specific address range                                         \n";
            std::cout << " 4. Show file information                                                      \n";
            std::cout << " 5. About DisassemblerX                                                        \n";
            std::cout << " 6. Exit                                                                        \n";
            std::cout << "================================================================================\n";
            std::cout << "Choice: ";

            int choice;
            std::cin >> choice;

            switch (choice) {
            case 1:
                disassemble(false);
                break;
            case 2:
                disassemble(true);
                break;
            case 3: {
                std::cout << "Enter start address (hex): 0x";
                qword startAddr;
                std::cin >> std::hex >> startAddr;
                std::cout << "Enter length (hex): 0x";
                qword length;
                std::cin >> std::hex >> length;

                auto sections = parser->getSections();
                for (const auto& section : sections) {
                    qword secStart = parser->getImageBase() + section.virtualAddress;
                    qword secEnd = secStart + section.size;

                    if (startAddr >= secStart && startAddr < secEnd) {
                        qword offset = startAddr - secStart;
                        qword availableLength = myMin(length, section.size - offset);

                        X86Decoder decoder(
                            fileData.data() + section.fileOffset + offset,
                            static_cast<size_t>(availableLength),
                            startAddr
                        );

                        std::cout << "\n[DisassemblerX] Disassembly from 0x" << std::hex << startAddr << ":\n\n";

                        while (decoder.getCurrentOffset() < availableLength) {
                            Instruction inst = decoder.decodeInstruction();
                            if (!inst.isValid) break;

                            std::cout << std::hex << std::setw(16) << std::setfill('0') << inst.address << "  ";
                            std::cout << std::setw(30) << std::left << std::setfill(' ') << formatBytes(inst.bytes);
                            std::cout << std::setw(8) << inst.mnemonic;

                            for (size_t i = 0; i < inst.operands.size(); i++) {
                                if (i > 0) std::cout << ", ";
                                std::cout << decoder.formatOperand(inst.operands[i]);
                            }
                            std::cout << "\n";
                        }
                        break;
                    }
                }
                break;
            }
            case 4: {
                std::cout << "\n================================================================================\n";
                std::cout << "                           File Information                                    \n";
                std::cout << "================================================================================\n";
                std::cout << " File: " << filePath << "\n";
                std::cout << " Size: " << fileData.size() << " bytes\n";
                std::cout << " Image Base: 0x" << std::hex << parser->getImageBase() << "\n";
                std::cout << " Entry Point: 0x" << std::hex << parser->getEntryPoint() << "\n";
                std::cout << "\n Sections:\n";

                auto sections = parser->getSections();
                for (const auto& section : sections) {
                    std::cout << "  " << std::setw(20) << std::left << section.name;
                    std::cout << " VA: 0x" << std::hex << std::setw(16) << std::setfill('0')
                        << (parser->getImageBase() + section.virtualAddress);
                    std::cout << " Size: 0x" << std::setw(8) << section.size;
                    std::cout << (section.isExecutable ? " [EXEC]" : "") << "\n";
                    std::setfill(' ');
                }
                std::cout << "================================================================================\n";
                break;
            }
            case 5: {
                std::cout << "\n================================================================================\n";
                std::cout << "                           About DisassemblerX                                 \n";
                std::cout << "================================================================================\n";
                std::cout << " DisassemblerX v" << DISASSEMBLERX_VERSION << "                                                              \n";
                std::cout << "                                                                                \n";
                std::cout << " Professional x86-64 Disassembler                                              \n";
                std::cout << "                                                                                \n";
                std::cout << " Developer: " << DISASSEMBLERX_AUTHOR << "                                                         \n";
                std::cout << " GitHub: " << DISASSEMBLERX_GITHUB << "                                      \n";
                std::cout << "                                                                                \n";
                std::cout << " " << DISASSEMBLERX_COPYRIGHT << " \n";
                std::cout << "                                                                                \n";
                std::cout << " This software is coded by @slyemane                          \n";
                std::cout << " Unauthorized use or distribution is prohibited                                \n";
                std::cout << "================================================================================\n";
                break;
            }
            case 6:
                std::cout << "\n[DisassemblerX] Thank you for using DisassemblerX by @slyemane!\n";
                std::cout << "Visit " << DISASSEMBLERX_GITHUB << " for updates.\n";
                return;
            default:
                std::cout << "[DisassemblerX] Invalid choice.\n";
            }
        }
    }
};

// ==================== Main Function ====================
int main(int argc, char* argv[]) {
    std::cout << "================================================================================\n";
    std::cout << "                                                                                \n";

    std::cout << "                                                                                \n";
    std::cout << "                     Professional x86-64 Disassembler                          \n";
    std::cout << "                            Version " << DISASSEMBLERX_VERSION << "                                         \n";
    std::cout << "                                                                                \n";
    std::cout << "                        Developed by: @slyemane                                \n";
    std::cout << "                   GitHub: https://github.com/slyemane                         \n";
    std::cout << "                                                                                \n";
    std::cout << "           Copyright (C) 2025 @slyemane - All Rights Reserved                  \n";
    std::cout << "================================================================================\n\n";

    std::string filePath;

    if (argc > 1) {
        filePath = argv[1];
    }
    else {
        std::cout << "[DisassemblerX] Enter the path to the executable file: ";
        std::getline(std::cin, filePath);
    }

    if (!filePath.empty() && filePath.front() == '"' && filePath.back() == '"') {
        filePath = filePath.substr(1, filePath.length() - 2);
    }

    if (!fileExists(filePath)) {
        std::cerr << "[DisassemblerX] Error: File '" << filePath << "' not found.\n";
        std::cerr << "Please check the path and try again.\n";
        return 1;
    }

    DisassemblerX disasm;
    if (!disasm.loadFile(filePath)) {
        return 1;
    }

    std::cout << "\n[DisassemblerX] File loaded successfully!\n";
    std::cout << "[DisassemblerX] Coded by @slyemane - https://github.com/slyemane\n";

    disasm.disassembleInteractive();

    return 0;
}